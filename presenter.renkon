{"padTitle":"presenter",
"positions":{"map":{"__map":true,
"values":[["1",{"height":697.2359837521559,
"id":"1",
"type":"move",
"width":530.5693771255451,
"x":-779.3419458477209,
"y":-352.5708833304911}],["7",{"height":1869.6637775251452,
"id":"7",
"type":"resize",
"width":676.7803258040567,
"x":-70.49899379863109,
"y":-353.96374292994017}],["12",{"height":1565.8820052484193,
"id":"12",
"type":"resize",
"width":627.9781380534331,
"x":1456.291385079744,
"y":-352.09405600108335}],["20",{"height":386.6328800704596,
"id":"20",
"type":"move",
"width":662.874826241493,
"x":-784.110653157341,
"y":382.2996345819207}],["24",{"height":1490.659886379065,
"id":"24",
"type":"resize",
"width":626.7241866735319,
"x":684.5741482218567,
"y":553.0520384190709}],["51",{"height":870.5568815517929,
"id":"51",
"type":"move",
"width":601.2026639803189,
"x":683.0335594555582,
"y":-356.5481130988294}],["54",{"height":922.5632420455216,
"id":"54",
"type":"resize",
"width":667.143711505082,
"x":2179.512993101045,
"y":-353.48465933608566}]]}},
"titles":{"map":{"__map":true,
"values":[["1",{"id":"1",
"state":false,
"title":"Initialization"}],["7",{"id":"7",
"state":false,
"title":"Rendering"}],["12",{"id":"12",
"state":false,
"title":"CSS"}],["20",{"id":"20",
"state":false,
"title":"newEditor"}],["24",{"id":"24",
"state":false,
"title":"Separator"}],["51",{"id":"51",
"state":false,
"title":"Scroll"}],["54",{"id":"54",
"state":false,
"title":"Save and Load"}]]}},
"version":3,
"windowEnabled":{"map":{"__map":true,
"values":[["1",{"enabled":true,
"id":"1"}],["7",{"enabled":true,
"id":"7"}],["12",{"enabled":true,
"id":"12"}],["20",{"enabled":true,
"id":"20"}],["24",{"enabled":true,
"id":"24"}],["51",{"enabled":true,
"id":"51"}],["54",{"enabled":true,
"id":"54"}]]}},
"windowTypes":{"map":{"__map":true,
"values":[["1","code"],["7","code"],["12","code"],["20","code"],["24","code"],["51","code"],["54","code"]]}},
"windows":["1","7","12","20","24","51","54"],
"zIndex":{"map":{"__map":true,
"values":[["1",110],["7",114],["12",103],["20",106],["24",115],["51",105],["54",113]]}}}
{__codeMap: true, value: [[`1`, `const init = (() => {
    const script = document.createElement("script");
    script.id = "markdownit";
    script.src = "./markdown-it.min.js";
    const promise = new Promise((resolve) => {
      script.onload = () => {
         resolve(window.markdownit);
      };
    });

    document.head.querySelector("#markdownit")?.remove();
    document.head.appendChild(script);

    const container = document.createElement("div");
    container.id = "container";
    document.body.querySelector("#container")?.remove();
    document.body.appendChild(container);
    container.innerHTML = \`
    <div id="result"></div>
    <div id="separator"></div>
    <div id="editorContainer">
      <div id="buttons">
        <button class="menuButton" id="save">save</button>
        <button class="menuButton" id="load">load</button>
      </div>
      <div id="editorContainer2"></div>
    </div>
\`.trim();
    return {markdownit: promise, container};
})();

const resolved = Behaviors.resolvePart(init);
const md = resolved.markdownit({html: true});
const container = resolved.container;
const separator = container.querySelector("#separator");
`],
[`7`, `const markdown = Behaviors.keep(md.render(editorString));
const map = Behaviors.keep(md.parse(editorString));
const hMap = map.filter((m) => m.type === "heading_open" && ["h1", "h2"].includes(m.tag));
const sections = [...resultDiv.querySelectorAll(":is(h1, h2)")];

const currentLineUpdated = ((currentSectionUpdated, sections, hMap) => {
  const index = sections.indexOf(currentSectionUpdated);
  return hMap[index].map?.[1];
})(currentSectionUpdated, sections, hMap);

const divTarget = Events.receiver();

const divGoto = ((divTarget) => {
  const result = container.querySelector("#result");
  if (!result) {return;}
  const resultRect = divTarget.getBoundingClientRect();
  result.scrollTop += divTarget.getBoundingClientRect().top;
  return divTarget;
})(divTarget);

const goto = ((currentLineUpdated, editor) => {
  const line = editor.state.doc.line(currentLineUpdated);
  /*
  I want to show the selected line at the top of the editor, but not sure how to do that.
  editor.dispatch({
    selection: { head: editor.state.doc.length, anchor: editor.state.doc.length },
    scrollIntoView: true
  });
  */

  editor.dispatch({
    selection: { head: line.from, anchor: line.from },
    scrollIntoView: true
  });
})(currentLineUpdated, editor);

const resultDiv = Behaviors.keep(((markdown, container) => {
  const div = document.createElement("div");
  div.id = "renkon";
  container.querySelector("#renkon")?.remove();
  container.querySelector("#result").appendChild(div);
  div.innerHTML = markdown;
  return div;
})(markdown, container));

const editor = newEditor("0", \`\`, callbackExt);
const callbackExt = new window.CodeMirror.state.Compartment();

const numberUpdated = Events.receiver();
const currentSection = Behaviors.collect(null, currentSectionUpdated, (_prev, currentSectionUpdated) => currentSectionUpdated);

const newSelectedDiv = ((hMap, sections, numberUpdated) => {
  for (let i = 0; i < hMap.length - 2; i++) {
    const prev = hMap[i].map;
    const next = hMap[i + 1].map;
    if (prev[0] <= numberUpdated && numberUpdated < next[0]) {
      return sections[i];
    }
  }
})(hMap, sections, numberUpdated);

const anotherGoto = ((newSelectedDiv, currentSection) => {
  if (newSelectedDiv === currentSection) {return;}
  Events.send(divTarget, newSelectedDiv);
})(newSelectedDiv, currentSection);

const editorString = Events.observe((notify) => {
  let lastText;
  const callback = window.CodeMirror.EditorView.updateListener.of((viewUpdate) => {
    if (viewUpdate.selectionSet) {
      const from = viewUpdate.state.selection.main?.from;
      const line = viewUpdate.state.doc.lineAt(from);
      if (line) {
        const number = line.number;
        Events.send(numberUpdated, number);
      }
      return;
    }
    const current = viewUpdate.state.doc.toString();
    if (lastText === undefined || current !== lastText) {
      if (lastText === undefined) {
        lastText = null;
      } else {
        lastText = current;
      }
      notify(current);
    }
  });
  editor.dispatch({
    effects: callbackExt.reconfigure([callback])
  });
  return () => {
    editor.dispatch({
      effects: callbackExt.reconfigure([])
    });    
  }
});

container.querySelector("#editorContainer2").appendChild(editor.dom);`],
[`12`, `const css = \`
#container, html, body {
  width: 100%;
  height: 100%;
  margin: 0px;
}

#container {
  display: flex;
}

#result {
  height: 100%;
  width: calc(100% - 220px);
  overflow: scroll;
  scroll-behavior: smooth;
}

#renkon {
  height: 100%;
}

#separator {
   width: 8px;
   min-width: 8px;
   height: 100%;
   background-color: #f8f8f8;
}

#separator:hover {
   background-color: #e8e8e8;
   cursor: ew-resize;
}

#editorContainer {
  position: fixed;
  right: 0px;
  min-height: 100%;
  height: 100%;
  width: 200px;
  border: 1px solid black;
  padding: 6px;
  min-width: 0px;
  background-color: white;
  white-space: pre-wrap;
  display: flex;
  flex-direction: column;
}

#editorContainer2 {
  overflow: scroll;
}

#buttons {
   display: flex;
   justify-content: right;
   margin-bottom: 6px;
}

.menuButton {
  font-family: 'OpenSans-SemiBold';
  color: black;
  margin-left: 4px;
  margin-right: 4px;
  border-radius: 4px;
  cursor: pointer;
  border: 2px solid #555;
}

\`.trim();

((css) => {
    document.head.querySelector("#presenter-style")?.remove();
    const style = document.createElement("style");
    style.id = "presenter-style";
    style.textContent = css;
    document.head.appendChild(style);

    document.head.querySelector("#separator-style")?.remove();
    const sepStyle = document.createElement("style");
    sepStyle.id = "separator-style";
    document.head.appendChild(sepStyle);
})(css);
`],
[`20`, `const newEditor = (id, doc, ext) => {
  const mirror = window.CodeMirror;

  const editor = new mirror.EditorView({
      doc: doc || \`# Hello, Renkon\`,

      extensions: [
          mirror.basicSetup,
          mirror.EditorView.lineWrapping,
          // mirror.EditorView.updateListener.of((viewUpdate) => callback(id, viewUpdate)),
          ext.of([]),
          mirror.EditorView.editorAttributes.of({"class": "editor"}),
          mirror.view.keymap.of([mirror.commands.indentWithTab])
      ],
  });
  editor.dom.id = \`\${id}-editor\`;
  return editor;
};
`],
[`24`, `const sepDown = Events.listener(
   separator,
   "pointerdown",
   evt => evt);

const down = Events.collect(undefined, sepDown, (old, evt) => {
  if (evt.isPrimary) {
    evt.target.setPointerCapture(evt.pointerId);
  }
  return {type: "sepDown", x: evt.clientX};
});

const up = Events.listener(
  separator,
  "pointerup",
  (evt) => {
    if (evt.isPrimary) {
      evt.target.releasePointerCapture(evt.pointerId);
    }
    return {type: "sepUp"}
  }
);

const _sepMove = Events.listener(separator, "pointermove", moveCompute);

const moveCompute = Behaviors.select(
  evt => evt,
  down, (_old, down) => {
    return (move) => {
      const newX = move.clientX;
      const newRenkonWidth = Math.min(window.innerWidth - 8, Math.max(newX - 8, 0));
      const newEditorWidth = Math.max(window.innerWidth - 22 - newRenkonWidth, 60);
      const showButton = newEditorWidth !== 60;
      const right = newEditorWidth === 60 ? -60 - 16 + (window.innerWidth - newX) : 0;

      document.head.querySelector("#separator-style").textContent = \`
#result {
  width: \${newRenkonWidth}px;
}
#editorContainer {
  width: \${newEditorWidth}px;
  right: \${right}px;
}

#buttons {
  visibility: \${showButton ? "visible" : "hidden"};
}


\`.trim();
      return move;
    }
  },
  up, (_old, _up) => (move) => move,
  resize, (old, resize) => {
    const newX = window.innerWidth - 22;
    const newEditorWidth = 60;
    const showButton = newEditorWidth !== 60;
    const right = -60;
    document.head.querySelector("#separator-style").textContent = \`
#result {
  width: \${newX}px;
}

#editorContainer {
  width: \${newEditorWidth}px;
  right: \${right}px;
}

#buttons {
  visibility: \${showButton ? "visible" : "hidden"};
}

\`.trim();
    return old;
  }
);

const resize = Events.listener(window, "resize", (evt) => ({type: "resize"}));
`],
[`51`, `// const key = Events.listener(document.body, "keydown", keyHandler);

const key = Events.observe((notify) => {
  const handler = evt => {
    if (evt.target !== document.body) {return;}
    if (evt.key !== "ArrowUp" && evt.key !== "ArrowDown") {return;}
    evt.preventDefault();
    notify(evt);
  };
  document.body.addEventListener("keydown", handler);
  return () => document.body.removeEventListener("keydown", handler);
});

const currentSectionUpdated = ((evt, sections) => {
  if (evt.target !== document.body) {return;}

  if (evt.key !== "ArrowUp" && evt.key !== "ArrowDown") {return;}
  let found;
  if (evt.key === "ArrowDown") {
    for (const section of sections) {
      const rect = section.getBoundingClientRect();
      if (rect.top >= 20) {
        found = section;
        break;
      }
    }
  } else if (evt.key === "ArrowUp") {
    for (let ind = sections.length - 1; ind >= 0; ind--) {
      const section = sections[ind];
      const rect = section.getBoundingClientRect();
      if (rect.top < -5) {
        found = section;
        break;
      }
    }    
  }
  if (!found) {return;}

  evt.preventDefault();

  Events.send(divTarget, found);

  return found;
})(key, sections);`],
[`54`, `const save = Events.listener(container.querySelector("#save"), "click", (evt) => evt)
const load = Events.listener(container.querySelector("#load"), "click", (evt) => evt)

const _saver = ((editor, save) => {
  const data = editor.state.doc.toString();

  const dataStr = "data:text/plain;charset=utf-8," + encodeURIComponent(data);
  const div = document.createElement("a");
  div.setAttribute("href", dataStr);
  div.setAttribute("download", \`presentation.md\`);
  div.click();
})(editor, save);

const loadData = (() => {
  const input = document.createElement("div");
  input.innerHTML = \`<input id="imageinput" type="file" accept=".md">\`;
  const imageInput = input.firstChild;

  imageInput.oncancel = () => imageInput.remove();
  document.body.appendChild(imageInput);
  imageInput.click();
  return new Promise((resolve, reject) => {
    imageInput.onchange = () => {
      const file = imageInput.files[0];
      if (!file) {imageInput.remove(); return;}
      let reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.readAsArrayBuffer(file);
    };
  }).then((data) => {
    imageInput.value = "";
    return new TextDecoder("utf-8").decode(data);
  });

})(load);

const _loader = ((loadData, editor) => {
  editor.dispatch({
    changes: {
      from: 0,
      to: editor.state.doc.length,
      insert: loadData
    }
  });
})(loadData, editor);`]]}